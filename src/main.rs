#![feature(asm)]
#![feature(fn_traits)]
#![feature(unboxed_closures)]

#[macro_use]
extern crate maplit;
#[macro_use]
extern crate lazy_static;

mod compiler;
mod interpreter;
mod jit;
mod parser;

use std::io::Result;
use std::process::Command;

use argparse::{ArgumentParser, StoreTrue, Store};

#[derive(Default)]
struct Config {
    keep_asm: bool,
    keep_o: bool,
    interpreter: bool,
    jit: bool
}

fn main() -> Result<()> {
    let mut filename = String::new();
    let mut config = Config::default();
    {
        let mut ap = ArgumentParser::new();
        ap.set_description("Compile a brainfuck program to x86_64 binaries.");
        ap.refer(&mut filename)
            .add_argument("filename", Store, "The file to be compiled.");
        ap.refer(&mut config.keep_asm)
            .add_option(&["--asm"], StoreTrue, "Keep nasm assembly files.");
        ap.refer(&mut config.keep_o)
            .add_option(&["--object"], StoreTrue, "Keep object files generated by nasm.");
        ap.refer(&mut config.interpreter)
            .add_option(&["-i"], StoreTrue, "Execute the .bf with an interpreter");
        ap.refer(&mut config.jit)
            .add_option(&["-j", "--jit"], StoreTrue, "Execute the .bf with JIT compiler");

        ap.parse_args_or_exit();
    }
    let input_string = std::fs::read_to_string(&filename)
        .unwrap_or_else(|_| panic!("Could not open file: {}", &filename));
    if !config.interpreter && !config.jit {
        let bf = compiler::Compilation::new(input_string);

        std::fs::write("out.asm", &bf.generate_assembly())?;
        println!("[Compiler]: Assembly generated to out.asm");

        nasm_assemble(&filename);
        macos_ld_link(&filename);
        asm_o_cleanup(&filename, &config);
    } else if config.interpreter {
        let mut bf = interpreter::Interpreter::new();
        bf.set_input(input_string);
        bf.execute()
    } else if config.jit {
        let mut context = jit::Context::new(64);
        let bf = jit::jit_compile(&parser::parse(&input_string).unwrap());
        let dump = jit::jit_compile_to_bytes(&parser::parse(&input_string).unwrap());
        std::fs::write("jit_bytes_dump.bin", dump).unwrap();
        println!("Program JIT compiled, executing now");
        bf(&mut context);
        println!("Output: {}", context.to_string());
    }
    Ok(())
}

fn nasm_assemble(_filename: &str) {
    let assembly_step = Command::new("nasm")
        .arg("-f")
        .arg("macho64")
        .arg("out.asm")
        .output()
        .expect("Could not run assembler (nasm)");

    println!("[Command]: nasm: {}", assembly_step.status);
    if !assembly_step.status.success() {
        println!("[Command]: nasm exited with message: {:#?}", assembly_step);
    }
}

fn macos_ld_link(filename: &str) {
    let link_step = Command::new("ld")
        .arg("out.o")
        .arg("-o")
        .arg(filename.split('.').next().unwrap().to_string())
        .arg("-macosx_version_min")
        .arg("10.13")
        .arg("-lSystem")
        .arg("-L/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib")
        .output()
        .expect("Could not run linker (ld)");

    println!("[Command]: ld: {}", link_step.status);
    if !link_step.status.success() {
        println!("[Command]: ld exited with message: {:#?}", link_step);
    } else {
    println!("[Compiler]: Artifact '{}' created", filename.split('.').next().unwrap());
    }

}

fn asm_o_cleanup(_filename: &str, config: &Config) {
    if !config.keep_o {
        let _o_cleanup_step = Command::new("rm")
            .arg("out.o")
            .output()
            .expect("Could not remove .o file");
    }

    if !config.keep_asm {
        let _asm_cleanup = Command::new("rm")
            .arg("out.asm")
            .output()
            .expect("Could not remove .asm file");
    }
}
